
#[macro_use]
extern crate clap;

use std::process::exit;
use std::path::PathBuf;

use std::ops::Deref;

fn main() {
    let matches = clap_app!(cachetools =>
        (version: "0.1")
        (author: "Matt Torrence <torrma01@gettysburg.edu>")
        (about: "Command line tool for managing the cache file generated by 'Addcomb' library")
        (@arg CACHE_FILE: -c --config +takes_value "Manage a cache file (defaults to using $HOME/.addcomb/cache.bincode, default cache for addcomb)")
        (@subcommand list =>
            (about: "List all the cached function values in a readable format")
        )
        (@subcommand union =>
            (about: "Merge two caches together")
            (@arg OTHER: +required "Other cache file to merge with")
            (@arg OUTPUT: -o --output +takes_value "Output cache file (defaults to overriding CACHE_FILE)")
        )
    )
    .get_matches();

    let dba = match matches.value_of("CACHE_FILE") {
        None => {
            cachetools::db_from_path(&*cachetools::CACHE_DATA_PATH.clone())   
        },
        Some(cfile) => {
            let path = PathBuf::from(cfile);
            cachetools::db_from_path(&path)
        }
    };

    if let Some(_matches) = matches.subcommand_matches("union") {
        unimplemented!();
    }
    else if let Some(_matches) = matches.subcommand_matches("list") {
        dba.read(|db| {
            println!("{:?}", db.map);
        }).unwrap();
    } else {
        eprintln!("Enter a valid subcommand (or --help for help)");
        exit(1);
    }
}
